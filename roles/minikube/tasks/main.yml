---
- name: Get latest Minikube version
  ansible.builtin.uri:
    url: https://api.github.com/repos/kubernetes/minikube/releases/latest
    return_content: yes
  register: minikube_latest_release
  when: minikube_version == "latest"

- name: Set Minikube version fact
  ansible.builtin.set_fact:
    minikube_install_version: "{{ minikube_latest_release.json.tag_name if minikube_version == 'latest' else minikube_version }}"

- name: Check if Minikube is already installed
  ansible.builtin.stat:
    path: "{{ minikube_install_path }}/minikube"
  register: minikube_binary

- name: Download Minikube binary
  ansible.builtin.get_url:
    url: "https://github.com/kubernetes/minikube/releases/download/{{ minikube_install_version }}/minikube-linux-amd64"
    dest: "{{ minikube_install_path }}/minikube"
    mode: '0755'
  when: not minikube_binary.stat.exists or minikube_version == "latest"

- name: Check if Minikube cluster is running
  ansible.builtin.command: minikube status
  register: minikube_status
  changed_when: false
  failed_when: false
  become: no

- name: Start Minikube cluster
  ansible.builtin.command: >
    minikube start
    --driver={{ minikube_driver }}
    --cpus={{ minikube_cpus }}
    --memory={{ minikube_memory }}
    --disk-size={{ minikube_disk_size }}
  when: minikube_status.rc != 0
  become: no
  environment:
    CHANGE_MINIKUBE_NONE_USER: "true"

- name: Enable Minikube addons
  ansible.builtin.command: "minikube addons enable {{ item }}"
  loop:
    - storage-provisioner
    - default-storageclass
    - metrics-server
    - dashboard
  changed_when: false
  become: no

- name: Deploy CoreDNS manifest
  ansible.builtin.shell: |
    kubectl apply -f - <<EOF
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: coredns
      namespace: kube-system
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: system:coredns
    rules:
    - apiGroups: [""]
      resources: ["endpoints", "services", "pods", "namespaces"]
      verbs: ["list", "watch"]
    - apiGroups: [""]
      resources: ["nodes"]
      verbs: ["get"]
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: system:coredns
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: system:coredns
    subjects:
    - kind: ServiceAccount
      name: coredns
      namespace: kube-system
    ---
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: coredns
      namespace: kube-system
    data:
      Corefile: |
        .:53 {
            errors
            health {
                lameduck 5s
            }
            ready
            kubernetes cluster.local in-addr.arpa ip6.arpa {
                pods insecure
                fallthrough in-addr.arpa ip6.arpa
                ttl 30
            }
            prometheus :9153
            forward . /etc/resolv.conf {
                max_concurrent 1000
            }
            cache 30
            loop
            reload
            loadbalance
        }
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: coredns
      namespace: kube-system
      labels:
        k8s-app: kube-dns
    spec:
      replicas: 2
      selector:
        matchLabels:
          k8s-app: kube-dns
      template:
        metadata:
          labels:
            k8s-app: kube-dns
        spec:
          serviceAccountName: coredns
          tolerations:
          - key: "CriticalAddonsOnly"
            operator: "Exists"
          containers:
          - name: coredns
            image: coredns/coredns:1.11.1
            imagePullPolicy: IfNotPresent
            args: ["-conf", "/etc/coredns/Corefile"]
            volumeMounts:
            - name: config-volume
              mountPath: /etc/coredns
              readOnly: true
            ports:
            - containerPort: 53
              name: dns
              protocol: UDP
            - containerPort: 53
              name: dns-tcp
              protocol: TCP
            - containerPort: 9153
              name: metrics
              protocol: TCP
            livenessProbe:
              httpGet:
                path: /health
                port: 8080
                scheme: HTTP
              initialDelaySeconds: 60
              timeoutSeconds: 5
              successThreshold: 1
              failureThreshold: 5
            readinessProbe:
              httpGet:
                path: /ready
                port: 8181
                scheme: HTTP
            resources:
              limits:
                memory: 170Mi
              requests:
                cpu: 100m
                memory: 70Mi
          volumes:
          - name: config-volume
            configMap:
              name: coredns
              items:
              - key: Corefile
                path: Corefile
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: kube-dns
      namespace: kube-system
      labels:
        k8s-app: kube-dns
    spec:
      selector:
        k8s-app: kube-dns
      clusterIP: 10.96.0.10
      ports:
      - name: dns
        port: 53
        protocol: UDP
      - name: dns-tcp
        port: 53
        protocol: TCP
      - name: metrics
        port: 9153
        protocol: TCP
    EOF
  args:
    executable: /bin/bash
  changed_when: true
  become: no

- name: Wait for Minikube to be ready
  ansible.builtin.command: kubectl get nodes
  register: kubectl_get_nodes
  until: kubectl_get_nodes.rc == 0
  retries: 10
  delay: 10
  changed_when: false
  become: no
